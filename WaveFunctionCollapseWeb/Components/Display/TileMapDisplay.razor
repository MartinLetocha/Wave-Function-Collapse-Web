@page "/tilegridoutput"
@using System.Globalization
@using WaveFunctionCollapseWeb.Data
@using WaveFunctionCollapseWeb.Models
@rendermode InteractiveServer

<div>
    <div class="wrapper"
         id="tileMap"
         @onwheel="OnWheel"
         @onmousedown="OnMouseDown"
         @onmouseup="OnMouseUp"
         @onmousemove="OnMouseMove"
         @onmouseleave="OnMouseLeave"
         oncontextmenu="return false;"
         @onwheel:preventDefault="true"
         style="width: @(displayWidth)vh; height: @(displayHeight)vh">

        <div class="canvas">

            <div class="grid"
                 style="grid-template-columns: repeat(@Height, @(ColumnSize)vh); grid-template-rows: repeat(@Width, @(RowSize)vh)">
                @for (int y = 0 + offsetY; y < Width + offsetY; y++)
                {
                    for (int x = 0 + offsetX; x < Height + offsetX; x++)
                    {
                        if (viewTiles.TryGetValue((x, y), out var id))
                        {
                            Tile tile = DataManager.GetTileFromDb(id);
                            if (tile.Image.Data == null)
                            {
                                <div class="cell"
                                     style="background: @tile.Background; color: @tile.TextColor">@(tile.Text)</div>
                            }
                            else
                            {
                                <div class="cell"
                                     style=" color: @tile.TextColor"><img src="TileImage?id=@tile.ID" loading="lazy"
                                                                          decoding="async" width="100%" height="100%"
                                                                          draggable="false"
                                                                          ondragstart="return false;"/><span>@(tile.Text)</span>
                                </div>
                            }
                        }
                        else
                        {
                            <div class="cell">?</div>
                        }
                    }
                }
            </div>

        </div>

    </div>

    <div class="zoom-display-output"><span>@offsetX,@offsetY</span> <span>@Width x @Height</span></div>
</div>

<script>
    window.getRelativePos = function (element, clientX, clientY) {
        const rect = element.getBoundingClientRect();
        return {
            x: clientX - rect.left,
            y: clientY - rect.top
        };
    };
    window.getViewportHeight = () => {
        return window.innerHeight;
    };
</script>

@code {
    [Parameter] public int displayWidth { get; set; }
    [Parameter] public int displayHeight { get; set; }
    [Parameter] public int size { get; set; }
    [Parameter] public double Sensitivity { get; set; }
    [Parameter] public EventCallback<double> SensitivityChanged { get; set; }

    //what is shown
    private Dictionary<(int, int), Guid> viewTiles = new();

    //avoiding multiple generation calls
    private bool blockGeneration = false;

    string ColumnSize => (displayHeight / (decimal)Height)
        .ToString(CultureInfo.InvariantCulture);

    string RowSize => (displayWidth / (decimal)Width)
        .ToString(CultureInfo.InvariantCulture);

    int Width = 12;
    int Height = 12;

    //dragging
    private bool isDragging = false;
    private Point startDrag;
    private int offsetX = 0;
    private int offsetY = 0;
    private bool isRightClick = false;


    protected override void OnInitialized()
    {
        if (DataManager.widthOutput != 0)
        {
            Width = DataManager.widthOutput;
            Height = DataManager.heightOutput;
        }

        offsetX = DataManager.offsetXOutput;
        offsetY = DataManager.offsetYOutput;
        // if (DataManager.viewTiles.Count >= 1)
        // {
        //     viewTiles = DataManager.viewTiles;
        //     return;
        // }
        if (blockGeneration)
        {
            return;
        }

        blockGeneration = true;
        Algorithm.WFCCore.Generate();
        viewTiles = DataManager.tiles;
    }

    void OnMouseDown(MouseEventArgs e)
    {
        if (e.Button == 2)
        {
            isRightClick = true;
        }

        viewTiles = DataManager.tiles;

        isDragging = true;
        startDrag = new Point(e.ScreenX, e.ScreenY);
    }

    // to solve mouse out of bounds dragging continuation
    void OnMouseLeave()
    {
        isDragging = false;
    }


    void OnMouseUp(MouseEventArgs e)
    {
        isDragging = false;
        if (isRightClick)
        {
            isRightClick = false;
            return;
        }

        DataManager.offsetXOutput = offsetX;
        DataManager.offsetYOutput = offsetY;
    }

    void OnMouseMove(MouseEventArgs e)
    {
        if (isRightClick)
        {
            return;
        }

        if (!isDragging) return;
        double xDifference = e.ScreenX - startDrag.X;
        double yDifference = e.ScreenY - startDrag.Y;
        if (xDifference >= (double)displayWidth / Width * Sensitivity || xDifference <= -((double)displayWidth / Width * Sensitivity))
        {
            startDrag.X = e.ScreenX;
            offsetX += 1 * (-Math.Sign(xDifference));
        }

        if (yDifference >= (double)displayHeight / Height * Sensitivity || yDifference <= -((double)displayHeight / Height * Sensitivity))
        {
            startDrag.Y = e.ScreenY;
            offsetY += 1 * (-Math.Sign(yDifference));
        }
    }

    void OnWheel(WheelEventArgs e)
    {
        if (e.DeltaY > 0)
        {
            if (Width >= 20)
                return;
            Width++;
            Height++;
        }
        else
        {
            if (Width <= 1)
                return;
            Width--;
            Height--;
        }

        DataManager.widthOutput = Width;
        DataManager.heightOutput = Height;
        //DataManager.viewTiles = viewTiles;
    }

}